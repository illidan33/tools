package method

import (
	"bytes"
	"fmt"
	"go/token"
	gotypes "go/types"
	"strings"
	ttempl "text/template"
	"tools/common"
	"tools/gen/util/types"
	"tools/template"

	"github.com/dave/dst"
)

var templateTxt = `// Code generated by "tools gen method"; DO NOT EDIT

package {{ .PackageName }}

import (
	"fmt"
	"github.com/jinzhu/gorm"
	"reflect"
)

{{ range $func := .TemplateDataMethodFuncs }}
{{html $func}}
{{end}}

`

var templateIndexMap = map[string]string{
	"FetchBy%s": `func ({{var $.ModelName}} *{{$.ModelName}}) FetchBy{{$.FuncName}}(db *gorm.DB) error {
		if err := db.Where("{{$.WhereStr}}", {{$.FieldStr}}).First({{var $.ModelName}}).Error; err != nil{
			return err
		}
		return nil
	}`,
	"UpdateBy%sWithStruct": `func ({{var $.ModelName}} *{{$.ModelName}}) UpdateBy{{$.FuncName}}WithStruct(db *gorm.DB) error {
		if err := db.Model({{var $.ModelName}}).Where("{{$.WhereStr}}", {{$.FieldStr}}).Updates({{var $.ModelName}}).Error; err != nil{
			return err
		}
		return nil
	}`,
	"UpdateBy%sWithMap": `func ({{var $.ModelName}} *{{$.ModelName}}) UpdateBy{{$.FuncName}}WithMap(db *gorm.DB, args map[string]interface{}) error {
		if err := db.Model({{var $.ModelName}}).Where("{{$.WhereStr}}", {{$.FieldStr}}).Updates(args).Error; err != nil{
			return err
		}
		return nil
	}`,
	"BatchFetchBy%s": `func ({{var $.ModelName}} *{{$.ModelName}}) BatchFetchBy{{$.FuncName}}(db *gorm.DB)({{var $.ModelName}}List []{{$.ModelName}}, err error) {
		err = db.Model({{var $.ModelName}}).Where("{{$.WhereStr}}", {{$.FieldStr}}).Find(&{{var $.ModelName}}List).Error
		return 
	}`,
}

var templateIndexUniqMap = map[string]string{
	"BatchFetchBy%sList": `func ({{var $.ModelName}} *{{$.ModelName}}) BatchFetchBy{{$.FuncName}}List(db *gorm.DB, {{var $.UniqFieldName}}List []{{$.UniqFieldType}})({{var $.ModelName}}List []{{$.ModelName}}, err error) {
		err = db.Where("{{snake $.UniqFieldName}} in (?)", {{var $.UniqFieldName}}List).Find(&{{var $.ModelName}}List).Error
		return 
	}`,
}

var templateBaseMap = map[string]string{
	"Create": `func ({{var $.ModelName}} *{{$.ModelName}}) Create(db *gorm.DB) (err error) {
		err = db.Create({{var $.ModelName}}).Error
		return 
	}`,
	"Delete": `func ({{var $.ModelName}} *{{$.ModelName}}) Delete(db *gorm.DB) (err error) {
		err = db.Delete({{var $.ModelName}}).Error
		return 
	}`,
	"FetchList": `func ({{var $.ModelName}} *{{$.ModelName}}) FetchList(db *gorm.DB, size int32, offset int32, count *int32, sql *string, args ...interface{})({{var $.ModelName}}List []{{$.ModelName}}, err error) {
		var newDb *gorm.DB
		if sql != nil {
			if size == -1 {
				newDb = db.Model({{var $.ModelName}}).Where(*sql, args...).Offset(offset).Find(&{{var $.ModelName}}List)
			} else {
				newDb = db.Model({{var $.ModelName}}).Where(*sql, args...).Offset(offset).Limit(size).Find(&{{var $.ModelName}}List)
			}
		} else {
			if len(args) > 1 {
				err = fmt.Errorf("args should be one,when sql is nil.")
				return
			}
			t := reflect.TypeOf(args[0])
			switch t.Kind() {
			case reflect.Struct:
				if size == -1 {
					newDb = db.Model({{var $.ModelName}}).Where(args[0]).Offset(offset).Find(&{{var $.ModelName}}List)
				} else {
					newDb = db.Model({{var $.ModelName}}).Where(args[0]).Offset(offset).Limit(size).Find(&{{var $.ModelName}}List)
				}
			case reflect.Map:
				if size == -1 {
					newDb = db.Model({{var $.ModelName}}).Where(args[0]).Offset(offset).Find(&{{var $.ModelName}}List)
				} else {
					newDb = db.Model({{var $.ModelName}}).Where(args[0]).Offset(offset).Limit(size).Find(&{{var $.ModelName}}List)
				}
			default:
				err = fmt.Errorf("args should be map or struct when sql is nil, but give %s.", t.Kind().String())
				return
			}
		}
		err = newDb.Error
		if err != nil {
			if gorm.IsRecordNotFoundError(err) {
				count = nil
				err = nil
			}
		} else if count != nil {
			newDb.Count(count)
		}
		return
	}`,
}

type TemplateDataMethod struct {
	template.GenTemplate
	template.TemplatePackage
	template.TemplateModel
	TemplateDataMethodFuncs  []string
	TemplateDataMethodIndexs []TemplateDataMethodIndex
}

type TemplateDataMethodFunc struct {
	ModelName     string
	ModelNames    string
	FuncName      string
	WhereStr      string
	FieldStr      string
	ConditionStr  string
	UniqFieldName string
	UniqFieldType string
}

type TemplateDataMethodIndex struct {
	Name   string
	Type   types.IndexType
	Fields []template.TemplateModelField
}

func (gt *TemplateDataMethod) GenFuncName(fields []template.TemplateModelField) string {
	str := ""
	for i, f := range fields {
		if i == 0 {
			str = f.Name
		} else {
			str += "_And" + f.Name
		}
	}
	return common.ToUpperCamelCase(str)
}

func (tgm *TemplateDataMethod) JoinFields(targetName string, fields []template.TemplateModelField) string {
	rs := ""
	for i, arg := range fields {
		if i == 0 {
			rs = fmt.Sprintf("%s.%s", targetName, arg.Name)
		} else {
			rs = fmt.Sprintf("%s, %s.%s", rs, targetName, arg.Name)
		}
	}
	return rs
}

func (tgm *TemplateDataMethod) JoinWhere(fields []template.TemplateModelField) string {
	rs := ""
	for i, arg := range fields {
		name := common.ToLowerSnakeCase(arg.GormName)
		if i == 0 {
			rs = fmt.Sprintf("%s=?", name)
		} else {
			rs = fmt.Sprintf("%s AND %s=?", rs, name)
		}
	}
	return rs
}

func (tgm *TemplateDataMethod) JoinConditions(fields []template.TemplateModelField) string {
	rs := ""
	for i, arg := range fields {
		if i == 0 {
			rs = fmt.Sprintf("%s %s", common.ToLowerCamelCase(arg.Name), arg.Type)
		} else {
			rs = fmt.Sprintf("%s, %s %s", rs, common.ToLowerCamelCase(arg.Name), arg.Type)
		}
	}
	return rs
}

func (tgm *TemplateDataMethod) parseMethodFuncsToTemplate(tp *ttempl.Template, td TemplateDataMethodFunc, templateTxt string, templateName string) (err error) {
	templateSource := &bytes.Buffer{}
	tp, err = tp.Parse(templateTxt)
	if err != nil {
		err = fmt.Errorf("parse [%s] template error: %s\n", templateName, err.Error())
		return
	}
	err = tp.Execute(templateSource, td)
	if err != nil {
		err = fmt.Errorf("execute [%s] tmplate data error: %s\n", templateName, err.Error())
		return
	}
	tgm.TemplateDataMethodFuncs = append(tgm.TemplateDataMethodFuncs, templateSource.String())
	return nil
}

func (tgm *TemplateDataMethod) ParseIndexToMethod(templateIndexMap, templateIndexUniqMap, templateBaseMap map[string]string) error {
	var err error
	td := TemplateDataMethodFunc{
		ModelName:  tgm.ModelName,
		ModelNames: tgm.ModelName + "List",
	}
	if len(tgm.TemplateMapFuncs) == 0 {
		tgm.InitTemplateFuncs()
	}
	tp := ttempl.New("gen_method")
	tp.Funcs(tgm.TemplateMapFuncs)
	for _, index := range tgm.TemplateDataMethodIndexs {
		// TODO(illidan/2020/9/28): foreign index not include
		if index.Type == types.INDEX_TYPE__FOREIGN_INDEX {
			continue
		}
		baseFuncName := tgm.GenFuncName(index.Fields)
		joinFields := tgm.JoinFields(common.ToLowerCamelCase(tgm.ModelName), index.Fields)
		joinWhere := tgm.JoinWhere(index.Fields)
		joinConditions := tgm.JoinConditions(index.Fields)
		td.FuncName = baseFuncName
		td.WhereStr = joinWhere
		td.FieldStr = joinFields
		td.ConditionStr = joinConditions

		for k, tpMethod := range templateIndexMap {
			if err = tgm.parseMethodFuncsToTemplate(tp, td, tpMethod, k); err != nil {
				return err
			}
		}

		if (index.Type == types.INDEX_TYPE__PRIMARY || index.Type == types.INDEX_TYPE__UNIQUE_INDEX) && len(index.Fields) == 1 {
			td.UniqFieldName = index.Fields[0].Name
			td.UniqFieldType = index.Fields[0].Type
			for k, tpMethod := range templateIndexUniqMap {
				if err = tgm.parseMethodFuncsToTemplate(tp, td, tpMethod, k); err != nil {
					return err
				}
			}
		}
	}

	for k, tpMethod := range templateBaseMap {
		if err = tgm.parseMethodFuncsToTemplate(tp, td, tpMethod, k); err != nil {
			return err
		}
	}
	return nil
}

func (tm *TemplateDataMethod) parseTagToTokens(s string) (rs []string, e error) {
	rs = make([]string, 0)
	tmp := bytes.Buffer{}
	keyS := false
	for i := 0; i < len(s); i++ {
		if s[i] == ' ' {
			ts := tmp.String()
			if keyS {
				tmp.WriteByte(s[i])
			} else if ts != "" {
				rs = append(rs, tmp.String())
				tmp = bytes.Buffer{}
			}
		} else {
			if s[i] == '"' {
				if keyS == false {
					keyS = true
				} else {
					keyS = false
				}
			}
			tmp.WriteByte(s[i])
		}
	}
	if tmp.String() != "" {
		rs = append(rs, tmp.String())
		tmp = bytes.Buffer{}
	}
	return
}

func (tm *TemplateDataMethod) ParseDecsToIndex(decs dst.Decorations, fieldMap *map[string]template.TemplateModelField) error {
	for _, dec := range decs {
		if strings.Contains(dec, "@def") {
			arr := strings.Split(dec, " ")
			if arr[0] == "//" && arr[1] == "@def" {
				tgmci := TemplateDataMethodIndex{}
				names := strings.Split(arr[2], ":")
				if len(names) > 1 {
					tgmci.Name = names[1]
				}
				switch names[0] {
				case types.INDEX_TYPE__PRIMARY.KeyLowerString():
					tgmci.Type = types.INDEX_TYPE__PRIMARY
				case types.INDEX_TYPE__UNIQUE_INDEX.KeyLowerString():
					tgmci.Type = types.INDEX_TYPE__UNIQUE_INDEX
				case types.INDEX_TYPE__INDEX.KeyLowerString():
					tgmci.Type = types.INDEX_TYPE__INDEX
				case types.INDEX_TYPE__FOREIGN_INDEX.KeyLowerString():
					tgmci.Type = types.INDEX_TYPE__FOREIGN_INDEX
				default:
				}
				tgmci.Fields = make([]template.TemplateModelField, 0)
				for i := 3; i < len(arr); i++ {
					if f, ok := (*fieldMap)[arr[i]]; !ok {
						return fmt.Errorf("index field of comment def is not struct field: %s", arr[i])
					} else {
						tgmci.Fields = append(tgmci.Fields, f)
					}
				}
				tm.TemplateDataMethodIndexs = append(tm.TemplateDataMethodIndexs, tgmci)
			}
		}
	}
	return nil
}

func (tm *TemplateDataMethod) parseTypesVar(v *gotypes.Var, tag string) []template.TemplateModelField {
	if v.Embedded() {
		t := v.Type()
		str := make([]template.TemplateModelField, 0)
		if ts, ok := t.Underlying().(*gotypes.Struct); ok {
			for i := 0; i < ts.NumFields(); i++ {
				tmp := tm.parseTypesVar(ts.Field(i), ts.Tag(i))
				str = append(str, tmp...)
			}
		}
		return str
	} else {
		templateField := template.TemplateModelField{
			Name:    v.Name(),
			Type:    v.Type().String(),
			Tag:     tag,
			Comment: "",
		}
		return []template.TemplateModelField{templateField}
	}
}

func (tm *TemplateDataMethod) ParseDstTree(file *dst.File) error {
	for _, i := range file.Decls {
		gd, ok := i.(*dst.GenDecl)
		if !ok {
			continue
		}
		if gd.Tok != token.TYPE {
			continue
		}
		tf, ok := gd.Specs[0].(*dst.TypeSpec)
		if !ok {
			return fmt.Errorf("can not change to TypeSpec: %#v", gd.Specs)
		}
		// this entity model name
		tm.ModelName = tf.Name.Name

		fieldMap := map[string]template.TemplateModelField{}
		if len(tm.TemplateModelFields) == 0 {
			st, ok := tf.Type.(*dst.StructType)
			if !ok {
				return fmt.Errorf("can not change to StructType: %#v", tf.Type)
			}

			for _, field := range st.Fields.List {
				templateField := template.TemplateModelField{}

				if len(field.Names) > 0 {
					templateField.Name = field.Names[0].Name
					templateField.JsonName = templateField.Name
					templateField.Tag = field.Tag.Value
					tagArr, err := tm.parseTagToTokens(templateField.Tag)
					if err != nil {
						return err
					}
					for _, s := range tagArr {
						if strings.Contains(s, types.MODEL_TAG_TYPE__GORM) {
							gormStr := common.GetDataBetweenFlag(s, "\"", "\"")
							gormFieldArr := strings.Split(gormStr, ";")
							for _, s2 := range gormFieldArr {
								if strings.Contains(s2, "column") {
									tmpArr := strings.Split(s2, ":")
									if len(tmpArr) > 1 {
										templateField.GormName = tmpArr[1]
									}
								}
							}
						}
					}
				}

				if len(field.Decs.NodeDecs.Start) > 0 {
					templateField.Comment = field.Decs.NodeDecs.Start[0]
				}
				if len(field.Decs.End) > 0 {
					templateField.Comment = field.Decs.End[0]
				}

				IdentType, ok := field.Type.(*dst.Ident)
				if ok {
					templateField.Type = IdentType.Name
				} else {
					ok = true
				}
				ExprType, ok := field.Type.(*dst.SelectorExpr)
				if ok {
					ExprXType, ok := ExprType.X.(*dst.Ident)
					if ok {
						templateField.Type = ExprXType.Name
					}
					templateField.Type += "." + ExprType.Sel.Name
				}
				fieldMap[templateField.Name] = templateField
				tm.TemplateModelFields = append(tm.TemplateModelFields, templateField)
			}
		} else {
			for _, field := range tm.TemplateModelFields {
				fieldMap[field.Name] = field
			}
		}

		// comment def of struct
		if gd.Decs.NodeDecs.Start != nil {
			decs := gd.Decs.NodeDecs.Start
			err := tm.ParseDecsToIndex(decs, &fieldMap)
			if err != nil {
				return err
			}
		}

		break
	}
	return nil
}

func (tm *TemplateDataMethod) ParseImportFile(filePath string) error {
	pkg, err := tm.GetTypesPackage(filePath)
	if err != nil {
		return err
	}

	elem := pkg.Scope().Lookup(tm.ModelName)
	strArr := make([]template.TemplateModelField, 0)
	if named, ok := elem.Type().(*gotypes.Named); ok {
		if ts, ok := named.Underlying().(*gotypes.Struct); ok {
			for i := 0; i < ts.NumFields(); i++ {
				tmp := tm.parseTypesVar(ts.Field(i), ts.Tag(i))
				strArr = append(strArr, tmp...)
			}
		}
	}
	tm.TemplateModelFields = strArr
	return nil
}

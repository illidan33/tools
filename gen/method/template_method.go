package method

import (
	"bytes"
	"fmt"
	"github.com/dave/dst"
	"go/token"
	"myprojects/tools/common"
	"myprojects/tools/gen"
	"myprojects/tools/gen/util/types"
	"strings"
	"text/template"
)

const templateMethodTxt = `// Code generated by "gen method"; DO NOT EDIT

package {{ .PackageName }}

import (
	"github.com/jinzhu/gorm"
)
{{ $ModelNames := printf "%ss" .ModelName }}

type {{$ModelNames}} []{{$.ModelName}}

{{ range $func := .TemplateDataMethodFuncs }}
{{ $func }}
{{end}}

`

const templateMethodFetchByIndexTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) FetchBy{{$.FuncName}}(db *gorm.DB) error {
	if err := db.Where("{{$.WhereStr}}", {{$.FieldStr}}).First({{var $.ModelName}}).Error; err != nil{
		return err
	}
	return nil
}`

const templateMethodUpdateByIndexWithStructTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) UpdateBy{{$.FuncName}}WithStruct(db *gorm.DB) error {
	if err := db.Model({{var $.ModelName}}).Where("{{$.WhereStr}}", {{$.FieldStr}}).Updates({{var $.ModelName}}).Error; err != nil{
		return err
	}
	return nil
}`

const templateMethodUpdateByIndexWithMapTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) UpdateBy{{$.FuncName}}WithMap(db *gorm.DB, args map[string]interface{}) error {
	if err := db.Model({{var $.ModelName}}).Where("{{$.WhereStr}}", {{$.FieldStr}}).Updates(args).Error; err != nil{
		return err
	}
	return nil
}`

const templateMethodCreateTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) Create(db *gorm.DB) error {
	if err := db.Create({{var $.ModelName}}).Error; err != nil{
		return err
	}
	return nil
}`

const templateMethodDeleteTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) Delete(db *gorm.DB) error {
	if err := db.Delete({{var $.ModelName}}).Error; err != nil {
		return err
	}
	return nil
}`

const templateMethodFetchListTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) FetchList(db *gorm.DB, args map[string]interface{})({{$.ConditionStr}}, err error) {
	err = db.Where(args).Find(&{{var $.ModelName}}).Error
	return 
}`

const templateMethodBatchFetchByIndexTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) BatchFetchBy{{$.FuncName}}(db *gorm.DB)({{$.ConditionStr}}, err error) {
	err = db.Where("{{$.WhereStr}}", {{$.FieldStr}}).Find(&{{var $.ModelName}}).Error
	return 
}`

const templateMethodBatchFetchByIndexListTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) BatchFetchBy{{$.FuncName}}List(db *gorm.DB, {{var $.UniqFieldName}}s []{{$.UniqFieldType}})({{var $.ModelName}}s []{{$.ModelName}}, err error) {
	err = db.Where("{{snake $.UniqFieldName}} in (?)", {{var $.UniqFieldName}}s).Find(&{{var $.ModelName}}s).Error
	return 
}`

type TemplateDataMethod struct {
	gen.GenTemplate
	gen.TemplatePackage
	gen.TemplateModel
	TemplateDataMethodFuncs  []string
	TemplateDataMethodIndexs []TemplateDataMethodIndex
}

type TemplateDataMethodFunc struct {
	ModelName     string
	ModelNames    string
	FuncName      string
	WhereStr      string
	FieldStr      string
	ConditionStr  string
	UniqFieldName string
	UniqFieldType string
}

type TemplateDataMethodIndex struct {
	Name   string
	Type   types.IndexType
	Fields []gen.TemplateModelField
}

func (gt *TemplateDataMethod) genFuncName(fields []gen.TemplateModelField) string {
	str := ""
	for i, f := range fields {
		if i == 0 {
			str = f.Name
		} else {
			str += "_And" + f.Name
		}
	}
	return common.ToUpperCamelCase(str)
}

func (tgm *TemplateDataMethod) joinFields(modelName string, fields []gen.TemplateModelField) string {
	rs := ""
	for i, arg := range fields {
		if i == 0 {
			rs = fmt.Sprintf("%s.%s", modelName, arg.Name)
		} else {
			rs = fmt.Sprintf("%s, %s.%s", rs, modelName, arg.Name)
		}
	}
	return rs
}

func (tgm *TemplateDataMethod) joinWhere(fields []gen.TemplateModelField) string {
	rs := ""
	for i, arg := range fields {
		name := common.ToLowerSnakeCase(arg.Name)
		if i == 0 {
			rs = fmt.Sprintf("%s=?", name)
		} else {
			rs = fmt.Sprintf("%s AND %s=?", rs, name)
		}
	}
	return rs
}

func (tgm *TemplateDataMethod) joinConditions(fields []gen.TemplateModelField) string {
	rs := ""
	for i, arg := range fields {
		if i == 0 {
			rs = fmt.Sprintf("%s %s", arg.Name, arg.Type)
		} else {
			rs = fmt.Sprintf("%s, %s %s", rs, arg.Name, arg.Type)
		}
	}
	return rs
}

func (tgm *TemplateDataMethod) parseMethodFuncsToTemplate(tp *template.Template, td TemplateDataMethodFunc, templateTxt string, templateName string) (err error) {
	templateSource := &bytes.Buffer{}
	tp, err = tp.Parse(templateTxt)
	if err != nil {
		return
	}
	err = tp.Execute(templateSource, td)
	if err != nil {
		return
	}
	tgm.TemplateDataMethodFuncs = append(tgm.TemplateDataMethodFuncs, templateSource.String())
	return nil
}

func (tgm *TemplateDataMethod) ParseIndexToMethod() error {
	var err error
	td := TemplateDataMethodFunc{
		ModelName:  tgm.ModelName,
		ModelNames: tgm.ModelName + "s",
	}
	tp := template.New("gen method")
	tp.Funcs(tgm.TemplateMapFuncs)
	for _, index := range tgm.TemplateDataMethodIndexs {
		baseFuncName := tgm.genFuncName(index.Fields)
		joinFields := tgm.joinFields(common.ToLowerCamelCase(tgm.ModelName), index.Fields)
		joinWhere := tgm.joinWhere(index.Fields)
		joinConditions := tgm.joinConditions(index.Fields)
		td = TemplateDataMethodFunc{
			ModelName:    tgm.ModelName,
			ModelNames:   tgm.ModelName + "s",
			FuncName:     baseFuncName,
			WhereStr:     joinWhere,
			FieldStr:     joinFields,
			ConditionStr: joinConditions,
		}
		if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodFetchByIndexTxt, "templateMethodFetchByIndexTxt"); err != nil {
			return err
		}
		if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodUpdateByIndexWithStructTxt, "templateMethodUpdateByIndexWithStructTxt"); err != nil {
			return err
		}
		if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodUpdateByIndexWithMapTxt, "templateMethodUpdateByIndexWithMapTxt"); err != nil {
			return err
		}
		if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodBatchFetchByIndexTxt, "templateMethodBatchFetchByIndexTxt"); err != nil {
			return err
		}

		if (index.Type == types.INDEXTYPE__PRIMARY || index.Type == types.INDEXTYPE__UNIQUE_INDEX) && len(index.Fields) == 1 {
			td.UniqFieldName = index.Fields[0].Name
			td.UniqFieldType = index.Fields[0].Type
			if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodBatchFetchByIndexListTxt, "templateMethodBatchFetchByIndexListTxt"); err != nil {
				return err
			}
		}
	}
	if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodCreateTxt, "templateMethodCreateTxt"); err != nil {
		return err
	}
	if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodDeleteTxt, "templateMethodDeleteTxt"); err != nil {
		return err
	}
	if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodFetchListTxt, "templateMethodFetchListTxt"); err != nil {
		return err
	}
	return nil
}

func (tm *TemplateDataMethod) parseTagToTokens(s string) (rs []string, e error) {
	rs = make([]string, 0)
	tmp := bytes.Buffer{}
	keyS := false
	for i := 0; i < len(s); i++ {
		if s[i] == ' ' {
			ts := tmp.String()
			if keyS {
				tmp.WriteByte(s[i])
			} else if ts != "" {
				rs = append(rs, tmp.String())
				tmp = bytes.Buffer{}
			}
		} else {
			if s[i] == '"' {
				if keyS == false {
					keyS = true
				} else {
					keyS = false
				}
			}
			tmp.WriteByte(s[i])
		}
	}
	if tmp.String() != "" {
		rs = append(rs, tmp.String())
		tmp = bytes.Buffer{}
	}
	return
}

func (tm *TemplateDataMethod) parseDecsToIndex(decs dst.Decorations, fieldMap *map[string]gen.TemplateModelField) error {
	for _, dec := range decs {
		if strings.Contains(dec, "@def") {
			arr := strings.Split(dec, " ")
			if arr[0] == "//" && arr[1] == "@def" {
				tgmci := TemplateDataMethodIndex{}
				names := strings.Split(arr[2], ":")
				if len(names) > 1 {
					tgmci.Name = names[1]
				}
				switch names[0] {
				case types.INDEXTYPE__PRIMARY.KeyLowerString():
					tgmci.Type = types.INDEXTYPE__PRIMARY
				case types.INDEXTYPE__UNIQUE_INDEX.KeyLowerString():
					tgmci.Type = types.INDEXTYPE__UNIQUE_INDEX
				case types.INDEXTYPE__INDEX.KeyLowerString():
					tgmci.Type = types.INDEXTYPE__INDEX
				default:
				}
				tgmci.Fields = make([]gen.TemplateModelField, 0)
				for i := 3; i < len(arr); i++ {
					if f, ok := (*fieldMap)[arr[i]]; !ok {
						return fmt.Errorf("index field of comment def is not struct field: %s", arr[i])
					} else {
						tgmci.Fields = append(tgmci.Fields, f)
					}
				}
				tm.TemplateDataMethodIndexs = append(tm.TemplateDataMethodIndexs, tgmci)
			}
		}
	}
	return nil
}

func (tm *TemplateDataMethod) ParseDstTree(file *dst.File) error {
	for _, i := range file.Decls {
		gd, ok := i.(*dst.GenDecl)
		if !ok {
			continue
		}
		if gd.Tok != token.TYPE {
			continue
		}
		tf, ok := gd.Specs[0].(*dst.TypeSpec)
		if !ok {
			return fmt.Errorf("can not change to TypeSpec: %#v", gd.Specs)
		}
		if tm.ModelName == "" {
			tm.ModelName = tf.Name.Name
		}

		st, ok := tf.Type.(*dst.StructType)
		if !ok {
			return fmt.Errorf("can not change to StructType: %#v", tf.Type)
		}

		fieldMap := map[string]gen.TemplateModelField{}
		for _, field := range st.Fields.List {
			templateField := gen.TemplateModelField{
				Name: field.Names[0].Name,
				Tag:  field.Tag.Value,
			}

			if len(field.Decs.NodeDecs.Start) > 0 {
				templateField.Comment = field.Decs.NodeDecs.Start[0]
			}
			if len(field.Decs.End) > 0 {
				templateField.Comment = field.Decs.End[0]
			}

			IdentType, ok := field.Type.(*dst.Ident)
			if ok {
				templateField.Type = IdentType.Name
			} else {
				ok = true
			}
			ExprType, ok := field.Type.(*dst.SelectorExpr)
			if ok {
				ExprXType, ok := ExprType.X.(*dst.Ident)
				if ok {
					templateField.Type = ExprXType.Name
				}
				templateField.Type += "." + ExprType.Sel.Name
			}
			fieldMap[templateField.Name] = templateField
			tm.TemplateModelFields = append(tm.TemplateModelFields, templateField)
		}

		// comment def of struct
		if gd.Decs.NodeDecs.Start != nil {
			decs := gd.Decs.NodeDecs.Start
			err := tm.parseDecsToIndex(decs, &fieldMap)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (tm *TemplateDataMethod) ParseTemplate(templateTxt string, templateName string, templateData interface{}) (templateSource *bytes.Buffer, e error) {
	templateSource = &bytes.Buffer{}
	tp := template.New(templateName)
	tp.Funcs(tm.TemplateMapFuncs)
	tp, e = tp.Parse(templateTxt)
	if e != nil {
		return
	}
	e = tp.Execute(templateSource, templateData)
	return
}

func (tm *TemplateDataMethod) Parse(filePath string) error {
	dstTree, err := tm.GetDstTree(filePath)
	if err != nil {
		return err
	}
	if err = tm.ParseDstTree(dstTree); err != nil {
		return err
	}
	if err = tm.ParseIndexToMethod(); err != nil {
		return err
	}
	return nil
}

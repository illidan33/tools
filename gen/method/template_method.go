package method

import (
	"bytes"
	"fmt"
	"github.com/dave/dst"
	"github.com/illidan33/tools/common"
	"github.com/illidan33/tools/gen"
	"github.com/illidan33/tools/gen/util/types"
	"go/importer"
	"go/token"
	gotypes "go/types"
	"os"
	"strings"
	"text/template"
)

const templateMethodTxt = `// Code generated by "tools"; DO NOT EDIT

package {{ .PackageName }}

import (
	"github.com/jinzhu/gorm"
)

{{ range $func := .TemplateDataMethodFuncs }}
{{html $func}}
{{end}}

`

const templateMethodFetchByIndexTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) FetchBy{{$.FuncName}}(db *gorm.DB) error {
	if err := db.Where("{{$.WhereStr}}", {{$.FieldStr}}).First({{var $.ModelName}}).Error; err != nil{
		return err
	}
	return nil
}`

const templateMethodUpdateByIndexWithStructTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) UpdateBy{{$.FuncName}}WithStruct(db *gorm.DB) error {
	if err := db.Model({{var $.ModelName}}).Where("{{$.WhereStr}}", {{$.FieldStr}}).Updates({{var $.ModelName}}).Error; err != nil{
		return err
	}
	return nil
}`

const templateMethodUpdateByIndexWithMapTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) UpdateBy{{$.FuncName}}WithMap(db *gorm.DB, args map[string]interface{}) error {
	if err := db.Model({{var $.ModelName}}).Where("{{$.WhereStr}}", {{$.FieldStr}}).Updates(args).Error; err != nil{
		return err
	}
	return nil
}`

const templateMethodCreateTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) Create(db *gorm.DB) error {
	if err := db.Create({{var $.ModelName}}).Error; err != nil{
		return err
	}
	return nil
}`

const templateMethodDeleteTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) Delete(db *gorm.DB) error {
	if err := db.Delete({{var $.ModelName}}).Error; err != nil {
		return err
	}
	return nil
}`

const templateMethodFetchListTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) FetchList(db *gorm.DB, size int32, offset int32, args map[string]interface{})({{var $.ModelName}}List []{{$.ModelName}}, count int32, err error) {
	err = db.Where(args).Offset(offset).Limit(size).Find(&{{var $.ModelName}}List).Count(&count).Error
	return 
}`

const templateMethodBatchFetchByIndexTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) BatchFetchBy{{$.FuncName}}(db *gorm.DB)({{var $.ModelName}}List []{{$.ModelName}}, err error) {
	err = db.Where("{{$.WhereStr}}", {{$.FieldStr}}).Find(&{{var $.ModelName}}List).Error
	return 
}`

const templateMethodBatchFetchByIndexListTxt = `func ({{var $.ModelName}} *{{$.ModelName}}) BatchFetchBy{{$.FuncName}}List(db *gorm.DB, {{var $.UniqFieldName}}List []{{$.UniqFieldType}})({{var $.ModelName}}List []{{$.ModelName}}, err error) {
	err = db.Where("{{snake $.UniqFieldName}} in (?)", {{var $.UniqFieldName}}List).Find(&{{var $.ModelName}}List).Error
	return 
}`

type TemplateDataMethod struct {
	gen.GenTemplate
	gen.TemplatePackage
	gen.TemplateModel
	TemplateDataMethodFuncs  []string
	TemplateDataMethodIndexs []TemplateDataMethodIndex
}

type TemplateDataMethodFunc struct {
	ModelName     string
	ModelNames    string
	FuncName      string
	WhereStr      string
	FieldStr      string
	ConditionStr  string
	UniqFieldName string
	UniqFieldType string
}

type TemplateDataMethodIndex struct {
	Name   string
	Type   types.IndexType
	Fields []gen.TemplateModelField
}

func (gt *TemplateDataMethod) genFuncName(fields []gen.TemplateModelField) string {
	str := ""
	for i, f := range fields {
		if i == 0 {
			str = f.Name
		} else {
			str += "_And" + f.Name
		}
	}
	return common.ToUpperCamelCase(str)
}

func (tgm *TemplateDataMethod) joinFields(modelName string, fields []gen.TemplateModelField) string {
	rs := ""
	for i, arg := range fields {
		if i == 0 {
			rs = fmt.Sprintf("%s.%s", modelName, arg.Name)
		} else {
			rs = fmt.Sprintf("%s, %s.%s", rs, modelName, arg.Name)
		}
	}
	return rs
}

func (tgm *TemplateDataMethod) joinWhere(fields []gen.TemplateModelField) string {
	rs := ""
	for i, arg := range fields {
		name := common.ToLowerSnakeCase(arg.Name)
		if i == 0 {
			rs = fmt.Sprintf("%s=?", name)
		} else {
			rs = fmt.Sprintf("%s AND %s=?", rs, name)
		}
	}
	return rs
}

func (tgm *TemplateDataMethod) joinConditions(fields []gen.TemplateModelField) string {
	rs := ""
	for i, arg := range fields {
		if i == 0 {
			rs = fmt.Sprintf("%s %s", arg.Name, arg.Type)
		} else {
			rs = fmt.Sprintf("%s, %s %s", rs, arg.Name, arg.Type)
		}
	}
	return rs
}

func (tgm *TemplateDataMethod) parseMethodFuncsToTemplate(tp *template.Template, td TemplateDataMethodFunc, templateTxt string, templateName string) (err error) {
	templateSource := &bytes.Buffer{}
	tp, err = tp.Parse(templateTxt)
	if err != nil {
		return
	}
	err = tp.Execute(templateSource, td)
	if err != nil {
		return
	}
	tgm.TemplateDataMethodFuncs = append(tgm.TemplateDataMethodFuncs, templateSource.String())
	return nil
}

func (tgm *TemplateDataMethod) ParseIndexToMethod() error {
	var err error
	td := TemplateDataMethodFunc{
		ModelName:  tgm.ModelName,
		ModelNames: tgm.ModelName + "s",
	}
	if len(tgm.TemplateMapFuncs) == 0 {
		tgm.InitTemplateFuncs()
	}
	tp := template.New("gen method")
	tp.Funcs(tgm.TemplateMapFuncs)
	for _, index := range tgm.TemplateDataMethodIndexs {
		// TODO(illidan/2020/9/28): foreign index not include
		if index.Type == types.INDEX_TYPE__FOREIGN_INDEX {
			continue
		}
		baseFuncName := tgm.genFuncName(index.Fields)
		joinFields := tgm.joinFields(common.ToLowerCamelCase(tgm.ModelName), index.Fields)
		joinWhere := tgm.joinWhere(index.Fields)
		joinConditions := tgm.joinConditions(index.Fields)
		td = TemplateDataMethodFunc{
			ModelName:    tgm.ModelName,
			ModelNames:   tgm.ModelName + "List",
			FuncName:     baseFuncName,
			WhereStr:     joinWhere,
			FieldStr:     joinFields,
			ConditionStr: joinConditions,
		}
		if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodFetchByIndexTxt, "templateMethodFetchByIndexTxt"); err != nil {
			return err
		}
		if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodUpdateByIndexWithStructTxt, "templateMethodUpdateByIndexWithStructTxt"); err != nil {
			return err
		}
		if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodUpdateByIndexWithMapTxt, "templateMethodUpdateByIndexWithMapTxt"); err != nil {
			return err
		}
		if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodBatchFetchByIndexTxt, "templateMethodBatchFetchByIndexTxt"); err != nil {
			return err
		}

		if (index.Type == types.INDEX_TYPE__PRIMARY || index.Type == types.INDEX_TYPE__UNIQUE_INDEX) && len(index.Fields) == 1 {
			td.UniqFieldName = index.Fields[0].Name
			td.UniqFieldType = index.Fields[0].Type
			if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodBatchFetchByIndexListTxt, "templateMethodBatchFetchByIndexListTxt"); err != nil {
				return err
			}
		}
	}
	if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodCreateTxt, "templateMethodCreateTxt"); err != nil {
		return err
	}
	if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodDeleteTxt, "templateMethodDeleteTxt"); err != nil {
		return err
	}
	if err = tgm.parseMethodFuncsToTemplate(tp, td, templateMethodFetchListTxt, "templateMethodFetchListTxt"); err != nil {
		return err
	}
	return nil
}

func (tm *TemplateDataMethod) parseTagToTokens(s string) (rs []string, e error) {
	rs = make([]string, 0)
	tmp := bytes.Buffer{}
	keyS := false
	for i := 0; i < len(s); i++ {
		if s[i] == ' ' {
			ts := tmp.String()
			if keyS {
				tmp.WriteByte(s[i])
			} else if ts != "" {
				rs = append(rs, tmp.String())
				tmp = bytes.Buffer{}
			}
		} else {
			if s[i] == '"' {
				if keyS == false {
					keyS = true
				} else {
					keyS = false
				}
			}
			tmp.WriteByte(s[i])
		}
	}
	if tmp.String() != "" {
		rs = append(rs, tmp.String())
		tmp = bytes.Buffer{}
	}
	return
}

func (tm *TemplateDataMethod) parseDecsToIndex(decs dst.Decorations, fieldMap *map[string]gen.TemplateModelField) error {
	for _, dec := range decs {
		if strings.Contains(dec, "@def") {
			arr := strings.Split(dec, " ")
			if arr[0] == "//" && arr[1] == "@def" {
				tgmci := TemplateDataMethodIndex{}
				names := strings.Split(arr[2], ":")
				if len(names) > 1 {
					tgmci.Name = names[1]
				}
				switch names[0] {
				case types.INDEX_TYPE__PRIMARY.KeyLowerString():
					tgmci.Type = types.INDEX_TYPE__PRIMARY
				case types.INDEX_TYPE__UNIQUE_INDEX.KeyLowerString():
					tgmci.Type = types.INDEX_TYPE__UNIQUE_INDEX
				case types.INDEX_TYPE__INDEX.KeyLowerString():
					tgmci.Type = types.INDEX_TYPE__INDEX
				case types.INDEX_TYPE__FOREIGN_INDEX.KeyLowerString():
					tgmci.Type = types.INDEX_TYPE__FOREIGN_INDEX
				default:
				}
				tgmci.Fields = make([]gen.TemplateModelField, 0)
				for i := 3; i < len(arr); i++ {
					if f, ok := (*fieldMap)[arr[i]]; !ok {
						return fmt.Errorf("index field of comment def is not struct field: %s", arr[i])
					} else {
						tgmci.Fields = append(tgmci.Fields, f)
					}
				}
				tm.TemplateDataMethodIndexs = append(tm.TemplateDataMethodIndexs, tgmci)
			}
		}
	}
	return nil
}

func (tm *TemplateDataMethod) ParseDstTree(file *dst.File) error {
	for _, i := range file.Decls {
		gd, ok := i.(*dst.GenDecl)
		if !ok {
			continue
		}
		if gd.Tok != token.TYPE {
			continue
		}
		tf, ok := gd.Specs[0].(*dst.TypeSpec)
		if !ok {
			return fmt.Errorf("can not change to TypeSpec: %#v", gd.Specs)
		}
		if tm.ModelName == "" {
			tm.ModelName = tf.Name.Name
		} else if tm.ModelName != tf.Name.Name {
			continue
		}

		fieldMap := map[string]gen.TemplateModelField{}
		if len(tm.TemplateModelFields) == 0 {
			st, ok := tf.Type.(*dst.StructType)
			if !ok {
				return fmt.Errorf("can not change to StructType: %#v", tf.Type)
			}

			for _, field := range st.Fields.List {
				templateField := gen.TemplateModelField{}

				if len(field.Names) > 0 {
					templateField.Name = field.Names[0].Name
					templateField.Tag = field.Tag.Value
				}

				if len(field.Decs.NodeDecs.Start) > 0 {
					templateField.Comment = field.Decs.NodeDecs.Start[0]
				}
				if len(field.Decs.End) > 0 {
					templateField.Comment = field.Decs.End[0]
				}

				IdentType, ok := field.Type.(*dst.Ident)
				if ok {
					templateField.Type = IdentType.Name
				} else {
					ok = true
				}
				ExprType, ok := field.Type.(*dst.SelectorExpr)
				if ok {
					ExprXType, ok := ExprType.X.(*dst.Ident)
					if ok {
						templateField.Type = ExprXType.Name
					}
					templateField.Type += "." + ExprType.Sel.Name
				}
				fieldMap[templateField.Name] = templateField
				tm.TemplateModelFields = append(tm.TemplateModelFields, templateField)
			}
		} else {
			for _, field := range tm.TemplateModelFields {
				fieldMap[field.Name] = field
			}
		}

		// comment def of struct
		if gd.Decs.NodeDecs.Start != nil {
			decs := gd.Decs.NodeDecs.Start
			err := tm.parseDecsToIndex(decs, &fieldMap)
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (tm *TemplateDataMethod) Parse(filePath string, isDebug bool) error {
	gofile := os.Getenv("GOFILE")
	importerFilePath := ""
	if isDebug {
		importerFilePath = strings.TrimPrefix(filePath, os.Getenv("GOPATH")+"/src/")
		importerFilePath = strings.TrimSuffix(importerFilePath, gofile)
	} else {
		importerFilePath = gofile
	}

	if err := tm.ImportFile(importerFilePath); err != nil {
		fmt.Println(err) // 记录错误，不打断，退化到由语法树来解析字段
	}

	dstTree, err := tm.GetDstTree(filePath)
	if err != nil {
		return err
	}
	if err = tm.ParseDstTree(dstTree); err != nil {
		return err
	}
	if err = tm.ParseIndexToMethod(); err != nil {
		return err
	}
	return nil
}

func (tm *TemplateDataMethod) ImportFile(filePath string) error {
	pkg, err := importer.For("source", nil).Import(filePath)
	if err != nil {
		return err
	}

	elem := pkg.Scope().Lookup(tm.ModelName)
	strArr := make([]gen.TemplateModelField, 0)
	if named, ok := elem.Type().(*gotypes.Named); ok {
		if ts, ok := named.Underlying().(*gotypes.Struct); ok {
			for i := 0; i < ts.NumFields(); i++ {
				tmp := tm.parseTypesVar(ts.Field(i), ts.Tag(i))
				strArr = append(strArr, tmp...)
			}
		}
	}
	tm.TemplateModelFields = strArr
	return nil
}

func (tm *TemplateDataMethod) parseTypesVar(v *gotypes.Var, tag string) []gen.TemplateModelField {
	if v.Embedded() {
		t := v.Type()
		str := make([]gen.TemplateModelField, 0)
		if ts, ok := t.Underlying().(*gotypes.Struct); ok {
			for i := 0; i < ts.NumFields(); i++ {
				tmp := tm.parseTypesVar(ts.Field(i), ts.Tag(i))
				str = append(str, tmp...)
			}
		}
		return str
	} else {
		templateField := gen.TemplateModelField{
			Name:    v.Name(),
			Type:    v.Type().String(),
			Tag:     tag,
			Comment: "",
		}
		return []gen.TemplateModelField{templateField}
	}
}

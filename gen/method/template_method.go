package method

import (
	"bytes"
	"fmt"
	"github.com/dave/dst"
	"go/token"
	"myprojects/tools/gen"
	"myprojects/tools/gen/types"
	"path/filepath"
	"strconv"
	"strings"
)

const templateMethodTxt = `// Code generated by "gen method"; DO NOT EDIT

package {{ .PackageName }}

import (
	"github.com/jinzhu/gorm"
)
{{ $structNames := printf "%ss" .StructName }}

type {{ $structNames }} []{{ .StructName }}

{{ range $value := .GormTable.Indexs }}
{{ $funcName := genFuncName $value }}
{{ $isUniqFunc := IsUniqFunc $value }}

{{if $isUniqFunc }}func ({{var $.StructName}} *{{ $.StructName }}) {{$funcName}}(db *gorm.DB, {{joinCondition $value.Fields}}) error {
	err := db.Where("{{joinArgs $value.Fields}}", {{joinCondition $value.Fields}}).First(&{{var $.StructName}}).Error
	if err != nil {
		return err
	}
	return nil
}
{{else}}
func ({{var $structNames}} *{{ $structNames }}) Batch{{$value.Name}}(db *gorm.DB, {{joinCondition $value.Fields}}) error {
	err := db.Where("{{joinArgs $value.Fields}}", {{joinCondition $value.Fields}}),.Find(&{{var $structNames}}).Error
	if err != nil {
		return err
	}
	return nil
}
{{end}}
{{end}}

func ({{var $structNames}} *{{ $structNames }}) FetchList(db *gorm.DB, args map[string]interface{}) error {
	err := db.Where(args).First(&{{var $structNames}}).Error
	if err != nil {
		return err
	}
	return nil
}`

type TemplateMethod struct {
	gen.TemplateGenStruct
	GormTable gen.GormTable
}

func registeTemplateFunc(tms *TemplateMethod) {
	tms.Init()
	tms.Registe(map[string]interface{}{
		"joinCondition": func(fields []gen.GormField) string {
			rs := ""
			for i, arg := range fields {
				if i == 0 {
					rs = fmt.Sprintf("%s", gen.ToLowerCamelCase(arg.Name))
				} else {
					rs = fmt.Sprintf("%s, %s", rs, gen.ToLowerCamelCase(arg.Name))
				}
			}
			return rs
		},
		"joinArgs": func(fields []gen.GormField) string {
			rs := ""
			for i, arg := range fields {
				if i == 0 {
					rs = fmt.Sprintf("%s=?", arg.Name)
				} else {
					rs = fmt.Sprintf("%s, %s=?", rs, arg.Name)
				}
			}
			return rs
		},
		"genFuncName": func(index gen.GormIndex) string {
			str := ""
			for i, f := range index.Fields {
				if i == 0 {
					str = f.Name
				} else {
					str += "_" + f.Name
				}
			}
			return gen.ToUpperCamelCase(str)
		},
		"IsUniqFunc": func(index gen.GormIndex) bool {
			if index.Type == types.INDEXTYPE__PRIMARY || index.Type == types.INDEXTYPE__UNIQUE_INDEX {
				return true
			}
			return false
		},
	})
}

func (sd *TemplateMethod) parseLineToTokens(s string) (rs []string, e error) {
	rs = make([]string, 0)
	tmp := bytes.Buffer{}
	keyS := false
	for i := 0; i < len(s); i++ {
		if s[i] == ' ' {
			ts := tmp.String()
			if keyS {
				tmp.WriteByte(s[i])
			} else if ts != "" {
				rs = append(rs, tmp.String())
				tmp = bytes.Buffer{}
			}
		} else {
			if s[i] == '"' {
				if keyS == false {
					keyS = true
				} else {
					keyS = false
				}
			}
			tmp.WriteByte(s[i])
		}
	}
	if tmp.String() != "" {
		rs = append(rs, tmp.String())
		tmp = bytes.Buffer{}
	}
	return
}

func (sd *TemplateMethod) parseDstTreeTag(tgsf gen.TemplateGenStructField, sort int) error {
	if tgsf.Tag == "" {
		return nil
	}
	lineStrs, err := sd.parseLineToTokens(strings.Trim(tgsf.Tag, "`"))
	if err != nil {
		return err
	}
	tfi := gen.GormField{
		Sort: sort,
	}
	for _, str := range lineStrs {
		if i := strings.Index(str, ":"); i != -1 {
			dataStr := strings.Trim(str[i+1:], "\"")
			switch str[:i] {
			case "json":
				tfi.Name = dataStr
			case "default":
				tfi.Default = dataStr
			case "gorm":
				gormArr := strings.Split(dataStr, ";")
				for _, ga := range gormArr {
					gsi := strings.Index(strings.Trim(ga, " "), ":")
					if gsi != -1 {
						switch ga[:gsi] {
						case "column":
							tfi.Name = ga[gsi+1:]
						case "type":
							tfi.SqlType = ga[gsi+1:]
							sqlS := strings.Index(tfi.SqlType, "(")
							if sqlS != -1 {
								tfi.SqlType = tfi.SqlType[:sqlS]
								tl, err := strconv.ParseUint(gen.GetDataBetweenFlag(ga[gsi+1:], "(", ")"), 10, 64)
								if err != nil {
									return err
								}
								tfi.TypeLen = tl
							}
							if v, ok := gen.FieldType[strings.ToUpper(tfi.SqlType)]; ok {
								tfi.Type = v
								if tfi.IsUnsigned {
									tfi.Type = "u" + tfi.Type
								}
							} else {
								return fmt.Errorf("Field type string not in map: %s", tfi.SqlType)
							}
						case "default":
							tfi.Default = strings.Trim(ga[gsi+1:], "'")
						case "unique_index":
							tfi.IsKeyField = true
							tfi.KeyName = ga[gsi+1:]
							tfi.KeyType = types.INDEXTYPE__UNIQUE_INDEX
						case "index":
							tfi.IsKeyField = true
							tfi.KeyName = ga[gsi+1:]
							tfi.KeyType = types.INDEXTYPE__INDEX
						default:
						}
					} else {
						switch strings.ToLower(ga) {
						case "not null":
							tfi.IsNull = false
						case "primary_key":
							tfi.IsKeyField = true
							tfi.KeyType = types.INDEXTYPE__PRIMARY
						case "unique":
							tfi.IsKeyField = true
							tfi.KeyName = tfi.Name
							tfi.KeyType = types.INDEXTYPE__UNIQUE_INDEX
						default:
						}
					}
				}
			default:
			}
		}
	}

	sd.GormTable.Fields[tfi.Name] = tfi

	if tfi.KeyName == "" {
		return nil
	}
	gi := gen.GormIndex{
		Name:   tfi.KeyName,
		Fields: []gen.GormField{},
		Type:   types.INDEXTYPE__INDEX,
		Using:  "BTREE",
	}
	v, ok := sd.GormTable.Indexs[gi.Name]
	if !ok {
		gi.Fields = append(gi.Fields, tfi)
		sd.GormTable.Indexs[gi.Name] = gi
	} else {
		v.Fields = append(v.Fields, tfi)
		sd.GormTable.Indexs[v.Name] = v
	}
	return nil
}

func (sd *TemplateMethod) parseDstTree(file *dst.File) error {
	sd.PackageName = file.Name.Name
	if sd.PackageName == "" {
		return fmt.Errorf("packageName empty: %v", file.Name)
	}
	for _, i := range file.Decls {
		gd, ok := i.(*dst.GenDecl)
		if !ok {
			continue
		}
		if gd.Tok != token.TYPE {
			continue
		}
		tf := gd.Specs[0].(*dst.TypeSpec)
		if sd.StructName == "" {
			sd.StructName = tf.Name.Name
		}

		st := tf.Type.(*dst.StructType)
		for k, field := range st.Fields.List {
			templateField := gen.TemplateGenStructField{
				Name: field.Names[0].Name,
				Tag:  field.Tag.Value,
			}

			if len(field.Decs.NodeDecs.Start) > 0 {
				templateField.Comment = field.Decs.NodeDecs.Start[0]
			}
			if len(field.Decs.End) > 0 {
				templateField.Comment = field.Decs.End[0]
			}

			IdentType, ok := field.Type.(*dst.Ident)
			if ok {
				templateField.Type = IdentType.Name
			} else {
				ok = true
			}
			ExprType, ok := field.Type.(*dst.SelectorExpr)
			if ok {
				ExprXType, ok := ExprType.X.(*dst.Ident)
				if ok {
					templateField.Type = ExprXType.Name
				}
				templateField.Type += "." + ExprType.Sel.Name
			}

			err := sd.parseDstTreeTag(templateField, k)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (sd *TemplateMethod) Parse(flags CmdGenMethodFlags) error {
	basePath, _ := filepath.Split(flags.CmdGenModleFilePath)
	s := strings.LastIndex(basePath, "/")
	if s == -1 {
		return fmt.Errorf("basepath error: %s", basePath)
	}

	sd.StructName = flags.CmdGenModleName

	dstTree, err := sd.GetDstTree(flags.CmdGenModleFilePath)
	if err != nil {
		return err
	}
	err = sd.parseDstTree(dstTree)
	if err != nil {
		return err
	}

	return nil
}

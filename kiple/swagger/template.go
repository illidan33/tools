package swagger

import (
	"errors"
	"fmt"
	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/fatih/structtag"
	"go/format"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"tools/common"
	"tools/gen"
)

var templateSwagTxt = `// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT
// This file was generated by swaggo/swag

package docs

import (
	"bytes"
	"encoding/json"
	"strings"

	"github.com/alecthomas/template"
	"github.com/swaggo/swag"
)

var doc = {{html $.Docs}}

type swaggerInfo struct {
	Version     string
	Host        string
	BasePath    string
	Schemes     []string
	Title       string
	Description string
}

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = swaggerInfo{
	Version:     "1.0.0",
	Host:        "",
	BasePath:    "",
	Schemes:     []string{},
	Title:       "GreenPacket kiplelive-agent API",
	Description: "This is greenpacket kiplelive-agent service.",
}

type s struct{}

func (s *s) ReadDoc() string {
	sInfo := SwaggerInfo
	sInfo.Description = strings.Replace(sInfo.Description, "\n", "\\n", -1)

	t, err := template.New("swagger_info").Funcs(template.FuncMap{
		"marshal": func(v interface{}) string {
			a, _ := json.Marshal(v)
			return string(a)
		},
	}).Parse(doc)
	if err != nil {
		return doc
	}

	var tpl bytes.Buffer
	if err := t.Execute(&tpl, sInfo); err != nil {
		return doc
	}

	return tpl.String()
}

func init() {
	swag.Register(swag.Name, &s{})
}
`

type TemplateKipleSwagger struct {
	gen.GenTemplate
	gen.TemplateModel

	ModelList            map[string]gen.TemplateModel
	ControllerUrls       map[string]string
	TemplateSwaggerPaths []TemplateSwaggerPath
	Swagger              SwaggerDocRoot
}

type TemplateSwaggerPath struct {
	Url        string
	Method     string
	Consumes   []string
	Produces   []string
	Tag        string
	Summary    string
	Parameters []map[string]interface{}
	Responses  map[string]SwaggerPathResp
}

type SwaggerRoot struct {
	Swagger     string                            `json:"swagger"`
	Info        SwaggerInfo                       `json:"info" yaml:"info"`
	Paths       map[string]map[string]SwaggerPath `json:"paths" yaml:"paths"`
	Definitions map[string]SwaggerDefinition      `json:"definitions" yaml:"definitions"`
}

type SwaggerDocRoot struct {
	Schemes  string `json:"schemes"`
	Host     string `json:"host"`
	BasePath string `json:"basePath"`
	SwaggerRoot
}

type SwaggerInfo struct {
	Description string      `json:"description" yaml:"description"`
	Title       string      `json:"title" yaml:"title"`
	Contact     interface{} `json:"contact" yaml:"contact"`
	Version     string      `json:"version" yaml:"version"`
}

type SwaggerPath struct {
	Consumes   []string                   `json:"consumes" yaml:"consumes"`
	Produces   []string                   `json:"produces" yaml:"produces"`
	Tags       []string                   `json:"tags" yaml:"tags"`
	Summary    string                     `json:"summary" yaml:"summary"`
	Parameters []map[string]interface{}   `json:"parameters" yaml:"parameters"`
	Responses  map[string]SwaggerPathResp `json:"responses" yaml:"responses"`
}

// replaced by map[string]interface{}
type SwaggerPathParam struct {
	Description string `json:"description" yaml:"description"`
	Name        string `json:"name" yaml:"name"`
	In          string `json:"in" yaml:"in"`
	Required    bool   `json:"required" yaml:"required"`
	SwaggerDefinitionProperty
}

type SwaggerPathResp struct {
	Description string            `json:"description" yaml:"description"`
	Schema      map[string]string `json:"schema" yaml:"schema"`
}

type SwaggerDefinition struct {
	Type       string                 `json:"type" yaml:"type"`
	Properties map[string]interface{} `json:"properties" yaml:"properties"`
}

type SwaggerDefinitionProperty struct {
	Description string            `json:"description" yaml:"description"`
	Type        string            `json:"type" yaml:"type"`
	Schema      map[string]string `json:"schema" yaml:"schema"`
	Items       map[string]string `json:"items" yaml:"items"`
}

var SwagTypeMap = map[string]string{
	"int8":    "integer",
	"int16":   "integer",
	"int":     "integer",
	"int32":   "integer",
	"int64":   "integer",
	"uint8":   "integer",
	"uint16":  "integer",
	"uint":    "integer",
	"uint32":  "integer",
	"uint64":  "integer",
	"float32": "integer",
	"float64": "integer",
	"bool":    "boolean",
	"string":  "string",
}

func (tm *TemplateKipleSwagger) getSwagDefPropertyType(modelName, tp string) string {
	if fType, ok := SwagTypeMap[tp]; ok {
		return fType
	} else if strings.HasPrefix(tp, "[]") {
		sourceType := strings.TrimPrefix(tp, "[]")
		return tm.getSwagDefPropertyType(modelName, sourceType)
	} else {
		return "#/definitions/" + modelName + "." + tp
	}
}

func (tm *TemplateKipleSwagger) getSwagSchema(modelPackage string, propertyType string) SwaggerDefinitionProperty {
	tmp := SwaggerDefinitionProperty{
		Schema: map[string]string{},
		Items:  map[string]string{},
	}
	if fType, ok := SwagTypeMap[propertyType]; ok {
		tmp.Type = fType
		tmp.Schema = nil
		tmp.Items = nil
	} else if strings.HasPrefix(propertyType, "[]") {
		tmp.Type = "array"
		tmp.Items = map[string]string{
			"$ref": "#/definitions/" + modelPackage + "." + strings.TrimPrefix(propertyType, "[]"),
		}
	} else {
		tmp.Type = "object"
		tmp.Schema = map[string]string{
			"$ref": "#/definitions/" + modelPackage + "." + propertyType,
		}
	}
	return tmp
}

func (tm *TemplateKipleSwagger) getSwagSchemaMap(modelName, propertyType, comment string) map[string]interface{} {
	sch := map[string]interface{}{
		"description": comment,
	}
	if fType, ok := SwagTypeMap[propertyType]; ok {
		sch["type"] = fType
	} else if strings.HasPrefix(propertyType, "[]") {
		sourceType := strings.TrimPrefix(propertyType, "[]")
		//sch["type"] = "array"
		sch["items"] = map[string]string{
			"$ref": tm.getSwagDefPropertyType(modelName, sourceType),
		}
	} else {
		//sch["type"] = "object"
		sch["schema"] = map[string]string{
			"$ref": tm.getSwagDefPropertyType(modelName, propertyType),
		}
	}
	return sch
}

func (tm *TemplateKipleSwagger) parseFuncDef(method, apiUrl, name, tag, comment string) error {
	method = strings.ToLower(strings.Trim(method, "\""))
	apiUrl = strings.Trim(apiUrl, "\"")
	name = strings.Trim(name, "\"")
	api := TemplateSwaggerPath{
		Url:        apiUrl,
		Method:     method,
		Consumes:   []string{"application/json"},
		Produces:   []string{"application/json"},
		Tag:        tag,
		Summary:    comment,
		Parameters: []map[string]interface{}{},
		Responses:  map[string]SwaggerPathResp{},
	}

	reqModelName := name + "RequestWl"
	isBody := false
	var req gen.TemplateModel
	for k, model := range tm.ModelList {
		if strings.HasSuffix(k, reqModelName) {
			req = model
			break
		}
	}
	if req.ModelName == "" {
		reqModelName = name + "Request"
		for k, model := range tm.ModelList {
			if strings.HasSuffix(k, reqModelName) {
				req = model
				isBody = true
				break
			}
		}
	}
	if req.ModelName == "" {
		return errors.New(reqModelName + " has no model request.")
	}

	if !isBody || (isBody && strings.ToUpper(method) == http.MethodGet) {
		for _, field := range req.TemplateModelFields {
			if field.JsonName == "-" {
				continue
			}
			tags, err := structtag.Parse(field.Tag)
			if err != nil {
				return err
			}
			inStr := ""
			if !isBody {
				in, _ := tags.Get("in")
				if in != nil {
					inStr = in.Name
				}
			} else {
				inStr = "query"
			}
			requiredTag, _ := tags.Get("require")
			requiredStr := ""
			required := false
			if requiredTag != nil {
				requiredStr = requiredTag.Name
				required, _ = strconv.ParseBool(requiredStr)
			}
			swaggerPm := map[string]interface{}{
				"name":     field.JsonName,
				"in":       inStr,
				"required": required,
			}
			sch := tm.getSwagSchemaMap(req.Package, field.Type, field.Comment)
			for k, v := range sch {
				swaggerPm[k] = v
			}
			api.Parameters = append(api.Parameters, swaggerPm)
		}
	} else {
		swaggerPm := map[string]interface{}{
			"name":     "body",
			"in":       "body",
			"required": true,
		}
		sch := tm.getSwagSchemaMap(req.Package, req.ModelName, req.ModelComment)
		for k, v := range sch {
			swaggerPm[k] = v
		}
		api.Parameters = append(api.Parameters, swaggerPm)
	}

	api.Responses = map[string]SwaggerPathResp{
		"200": {
			Description: "OK",
			Schema:      nil,
		},
	}
	respModelName := name + "Response"
	resp, ok := tm.ModelList[respModelName]
	if ok {
		tmp := api.Responses["200"]
		tmp.Schema = map[string]string{
			"$ref": "#/definitions/" + resp.Package + "." + resp.ModelName,
		}
		api.Responses["200"] = tmp
	}

	tm.TemplateSwaggerPaths = append(tm.TemplateSwaggerPaths, api)
	return nil
}

func (tm *TemplateKipleSwagger) ParsePojoDir(dir string) error {
	if !common.IsExists(dir) {
		return errors.New(dir + " is not exist")
	}

	mList, err := tm.ParseModelDir(dir)
	if err != nil {
		return err
	}
	for _, model := range mList {
		tm.ModelList[model.ModelName] = model

		swagDef := SwaggerDefinition{
			Type:       "object",
			Properties: map[string]interface{}{},
		}
		for _, field := range model.TemplateModelFields {
			if field.JsonName == "-" {
				continue
			}
			swagDef.Properties[field.JsonName] = tm.getSwagSchemaMap(model.Package, field.Type, field.Comment)
		}
		tm.Swagger.Definitions[fmt.Sprintf("%s.%s", model.Package, model.ModelName)] = swagDef
	}

	return nil
}

func (tm *TemplateKipleSwagger) genDstFileToFile(dstFilePath string, node *dst.File) (err error) {
	fset, af, e := decorator.RestoreFile(node)
	if e != nil {
		err = e
		return
	}

	var file *os.File
	file, err = os.OpenFile(dstFilePath, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0644)
	if err != nil {
		return err
	}
	defer file.Close()
	err = format.Node(file, fset, af)

	return
}

func (tm *TemplateKipleSwagger) ParseSwagTitle(file string) error {
	dstFile, err := tm.GetDstTree(file)
	if err != nil {
		return err
	}
	for _, decl := range dstFile.Decls {
		fun, ok := decl.(*dst.FuncDecl)
		if !ok {
			continue
		}
		if fun.Name.Name != "main" {
			continue
		}
		ttl, ver, desc := false, false, false
		for _, s := range fun.Decs.Start.All() {
			i := strings.Index(s, "@")
			if i == -1 {
				continue
			}
			s = s[i+1:]
			space := strings.Index(s, " ")
			if space == -1 {
				continue
			}
			v := strings.TrimSpace(s[space+1:])
			switch s[:space] {
			case "title":
				ttl = true
				tm.Swagger.Info.Title = v
			case "version":
				ver = true
				tm.Swagger.Info.Version = v
			case "description":
				desc = true
				tm.Swagger.Info.Description = v
			default:

			}
		}
		rootName := filepath.Base(filepath.Dir(file))
		if !ttl {
			fun.Decs.Start.Append(fmt.Sprintf("// @title %s", rootName))
		}
		if !ver {
			fun.Decs.Start.Append("// @version 1.0.0")
		}
		if !desc {
			fun.Decs.Start.Append(fmt.Sprintf("// @description This is api document of %s service.", rootName))
		}
	}

	flag := false
	for _, imp := range dstFile.Imports {
		if imp.Name == nil || imp.Name.Name != "_" {
			continue
		}
		path := strings.Trim(imp.Path.Value, "\"")
		if strings.HasSuffix(filepath.Dir(file), filepath.Dir(path)) && filepath.Base(path) == "docs" {
			flag = true
			break
		}
	}
	if !flag {
		projectPkg, err := common.GetPackageFromDir(filepath.Dir(file))
		if err != nil {
			return err
		}
		docImp := &dst.ImportSpec{
			Name: &dst.Ident{
				Name: "_",
				Obj:  nil,
				Path: "",
				Decs: dst.IdentDecorations{},
			},
			Path: &dst.BasicLit{
				Kind:  9,
				Value: fmt.Sprintf("\"%s/docs\"", projectPkg),
				Decs:  dst.BasicLitDecorations{},
			},
			Decs: dst.ImportSpecDecorations{
				NodeDecs: dst.NodeDecs{
					Before: 0,
					Start:  nil,
					End: dst.Decorations{
						"// docs is generated by Swag CLI, you have to import it.",
					},
					After: 0,
				},
				Name: nil,
			},
		}
		dstFile.Imports = append(dstFile.Imports, docImp)
		err = tm.genDstFileToFile(file, dstFile)
		if err != nil {
			return errors.New("FormatCodeToFile - write file error: " + err.Error())
		}
	}
	return nil
}

func (tm *TemplateKipleSwagger) ParseControllerDir(dir string) error {
	if !common.IsExists(dir) {
		return errors.New(dir + " is not exist")
	}

	rd, err := ioutil.ReadDir(dir)
	if err != nil {
		return err
	}
	for _, file := range rd {
		if file.IsDir() {
			tm.ParseControllerDir(file.Name())
		} else {
			dstFile, err := tm.GetDstTree(filepath.Join(dir, file.Name()))
			if err != nil {
				return err
			}
			for _, decl := range dstFile.Decls {
				fc, ok := decl.(*dst.FuncDecl)
				if !ok {
					continue
				}
				if fc.Name.Name == "BeforeActivation" {
					for _, stmt := range fc.Body.List {
						expr, ok := stmt.(*dst.ExprStmt)
						if !ok {
							continue
						}
						call, ok := expr.X.(*dst.CallExpr)
						if !ok {
							continue
						}
						if len(call.Args) < 3 {
							break
						}
						method, ok := call.Args[0].(*dst.BasicLit)
						url, ok := call.Args[1].(*dst.BasicLit)
						name, ok := call.Args[2].(*dst.BasicLit)
						comment := tm.ParseDstCommentFromNode(expr.Decs.NodeDecs)
						tag := tm.ParseDstNodeType(fc.Recv.List[0].Type)
						err = tm.parseFuncDef(method.Value, url.Value, name.Value, tag, comment)
						if err != nil {
							return err
						}
					}
				} else if fc.Name.Name == "RegisterGlobalModel" {
					for i := 0; i < len(fc.Body.List); i++ {
						exprStmt, ok := fc.Body.List[i].(*dst.ExprStmt)
						if !ok {
							continue
						}
						fun, ok := exprStmt.X.(*dst.CallExpr)
						if !ok {
							continue
						}
						if len(fun.Args) != 2 {
							break
						}
						call, ok := fun.Args[0].(*dst.CallExpr)
						if !ok {
							break
						}
						cFun, ok := fun.Args[1].(*dst.FuncLit)
						if !ok {
							break
						}
						for _, stmt := range cFun.Body.List {
							exprStmt1, ok := stmt.(*dst.ExprStmt)
							if !ok {
								break
							}
							fun1, ok := exprStmt1.X.(*dst.CallExpr)
							if !ok {
								break
							}
							unary, ok := fun1.Args[0].(*dst.UnaryExpr)
							if !ok {
								break
							}
							comp, ok := unary.X.(*dst.CompositeLit)
							if !ok {
								break
							}
							path := strings.Trim(call.Args[0].(*dst.BasicLit).Value, "\"")
							tm.ControllerUrls[comp.Type.(*dst.Ident).Name] = path
						}
					}
				}
			}
		}
	}
	return nil
}

func (tm *TemplateKipleSwagger) SetSwaggerPaths() {
	for _, path := range tm.TemplateSwaggerPaths {
		api := SwaggerPath{
			Consumes:   path.Consumes,
			Produces:   path.Produces,
			Tags:       []string{path.Tag},
			Summary:    path.Summary,
			Parameters: path.Parameters,
			Responses:  path.Responses,
		}
		newPath := path.Url
		if p, ok := tm.ControllerUrls[path.Tag]; ok {
			p = strings.Trim(p, "/")
			path.Url = strings.Trim(path.Url, "/")
			newPath = fmt.Sprintf("/%s/%s", p, path.Url)
		}
		if p, ok := tm.Swagger.Paths[newPath]; ok {
			p[path.Method] = api
			tm.Swagger.Paths[newPath] = p
		} else {
			tm.Swagger.Paths[newPath] = map[string]SwaggerPath{
				path.Method: api,
			}
		}
	}
}
